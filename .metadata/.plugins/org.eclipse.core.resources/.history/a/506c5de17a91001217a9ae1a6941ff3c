package it.garr.greenmst;

import it.garr.greenmst.types.ComparableLink;
import it.garr.greenmst.web.GreenMSTWebRoutable;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.ExecutionException;

import net.floodlightcontroller.core.IFloodlightProviderService;
import net.floodlightcontroller.core.module.FloodlightModuleContext;
import net.floodlightcontroller.core.module.FloodlightModuleException;
import net.floodlightcontroller.core.module.IFloodlightModule;
import net.floodlightcontroller.core.module.IFloodlightService;
import net.floodlightcontroller.linkdiscovery.ILinkDiscovery;
import net.floodlightcontroller.linkdiscovery.ILinkDiscovery.LDUpdate;
import net.floodlightcontroller.restserver.IRestApiService;
import net.floodlightcontroller.topology.ITopologyListener;
import net.floodlightcontroller.topology.ITopologyService;

import org.openflow.protocol.OFPhysicalPort;
import org.openflow.protocol.OFPhysicalPort.OFPortConfig;
import org.openflow.protocol.OFPortMod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Implementation of the Floodlight GreenMST service.
 *
 * @author Luca Prete <luca.prete@garr.it>
 * @author Andrea Biancini <andrea.biancini@garr.it>
 * @author Fabio Farina <fabio.farina@garr.it>
 * 
 * @version 0.8
 * @see net.floodlightcontroller.core.module.IFloodlightModule
 * @see net.floodlightcontroller.topology.ITopologyListener
 * @see it.garr.greenmst.types.ComparableLink
 * @see it.garr.greenmst.IGreenMSTService
 *
 */

public class GreenMST implements IFloodlightModule, IGreenMSTService, ITopologyListener {
	
	protected IRestApiService restApi = null;
	protected IFloodlightProviderService floodlightProvider = null;
	protected ITopologyService topology = null;
	protected static Logger logger = null;
	
	// Data structures for Kruskal
	protected TreeSet<ComparableLink> topoEdges = new TreeSet<ComparableLink>();
	protected HashSet<ComparableLink> redundantEdges = new HashSet<ComparableLink>();
	
	@Override
	public void topologyChanged() {		
		for (LDUpdate update : topology.getLastLinkUpdates()) {
			ComparableLink link = new ComparableLink(update.getSrc(), update.getSrcPort(), update.getDst(), update.getDstPort());
			
			if (update.getOperation().equals(ILinkDiscovery.UpdateOperation.LINK_REMOVED)) { 
	            logger.debug("Link removed: " + link.toString());
	            if (!topoEdges.contains(link)) {
	            	topoEdges.remove(link);
	            	updateLinks();
	            }
			} else if(update.getOperation().equals(ILinkDiscovery.UpdateOperation.LINK_UPDATED)) {
				logger.debug("Link updated: " + link.toString());
				if (!topoEdges.contains(link)) {
	                topoEdges.add(link);
	                updateLinks();
	            }
			}
		}
	}
	
	private void updateLinks() {
        // Perform Kruskal
        try {
        	Vector<ComparableLink> mstEdges = performKruskal(nodes);
            // In mstEdges we now have all edges of the MST
            // topoEdges still contains a list of all edges of the known physical network   
            HashSet<ComparableLink> redundantEdges = removeRedundantEdges(mstEdges);
            // redundantEdges contains edges to be closed according to Kruskal
            // (ie edges in topoEdges but not present in mstEdges, edges not in MSP and not already closed)
            
            // Close edges in redundantEdges
            for (ComparableLink s : redundantEdges) {
                if (!this.redundantEdges.contains(s)) {
                	// Closes both direction of the link
                	modPort(s.getSrc(), s.getSrcPort(), false);
                	//modPort(s.getDst(), s.getDstPort(), false);
                }
            }
            
            // Re-open ports in MSP which were closed in previous iterations
            // (ie edges in the redundantEdges, from previous execution, and not in the current execution)
            for (ComparableLink s : this.redundantEdges) {
                if (!redundantEdges.contains(s)) {
                	// Opens both direction of the link
                	modPort(s.getSrc(), s.getSrcPort(), true);
                	//modPort(s.getDst(), s.getDstPort(), true);
                }
            }
            
            // Clone redundantEdges in redundantEdges for future iterations
            this.redundantEdges = redundantEdges;
            // printFinalEdges();
        } catch (Exception e) {
            logger.error("Error calculating MST with Kruskal ", e);
        }
    }
	
	// KRUSKAL ALGORITHM -- COLUMBIA UNIV. IMPL.
    private Vector<ComparableLink> performKruskal() throws Exception {
    	HashMap<Long, HashSet<Long>> nodes = new HashMap<Long, HashSet<Long>>();
		
        // Generates nodes Hashmap containing one entry for each switch
        for (ComparableLink lt: topoEdges) {
            if (!nodes.containsKey(lt.getSrc())) {
            	// Create set of connect components [singleton] for this node
                nodes.put(lt.getSrc(), new HashSet<Long>());
                nodes.get(lt.getSrc()).add(lt.getSrc());
            }
            
            if (!nodes.containsKey(lt.getDst())) {
            	// Create set of connect components [singleton] for this node
                nodes.put(lt.getDst(), new HashSet<Long>());
                nodes.get(lt.getDst()).add(lt.getDst());
            }
        }
    	
    	Vector<ComparableLink> mstEdges = new Vector<ComparableLink>();
    	Vector<ComparableLink> edgesDone = new Vector<ComparableLink>();
    	
    	for (ComparableLink curEdge: topoEdges) {
	        if (!edgesDone.contains(curEdge)) {
	        	edgesDone.add(curEdge); // This way the same edge will not be processed two times (if present two times in topoEdges)
	        	if (!nodes.get(curEdge.getSrc()).equals(nodes.get(curEdge.getDst()))) {
	        		HashSet<Long> src = null, dst = null;
	        		Long dstHashSetIndex;
	        		if (nodes.get(curEdge.getSrc()).size() > nodes.get(curEdge.getDst()).size()) {
	        			// have to transfer all nodes including curEdge.to
	        			src = nodes.get(curEdge.getDst());
	        			dst = nodes.get(dstHashSetIndex = curEdge.getSrc());
	        		} else {
	        			// have to transfer all nodes including curEdge.from
	        			src = nodes.get(curEdge.getSrc());
	        			dst = nodes.get(dstHashSetIndex = curEdge.getDst());
	        		}
	        		Object[] srcArray = src.toArray();
	        		int transferSize = srcArray.length;
	        		for (int j = 0; j < transferSize; j++) {
	        			// move each node from set: src into set: dst
	        			// and update appropriate index in array: nodes
	        			if (src.remove(srcArray[j])) {
	        				dst.add((Long) srcArray[j]);
	        				nodes.put((Long) srcArray[j], nodes.get(dstHashSetIndex));
	        			} else {
	        				logger.error("Kruskal - Error performing Kruskal algorithm (set union)");
	        				throw new Exception("Kruskal - Error performing Kruskal algorithm (set union)");
	        			}
	        		}
	        		mstEdges.add(curEdge);
	        	}
	        }
    	}
    	
    	return mstEdges;
    }
	
    private HashSet<ComparableLink> removeRedundantEdges(Vector<ComparableLink> mstEdges) {
    	HashSet<ComparableLink> redundantEdges = new HashSet<ComparableLink>();
    	
    	for (ComparableLink lt: topoEdges) {
    		ComparableLink ltInverse = lt.getInverse();
    		if (!mstEdges.contains(lt) && !mstEdges.contains(ltInverse)) {
                redundantEdges.add(lt);
            }
        }
    	
    	return redundantEdges;
    }
    
	private void modPort(long switchId, short portNum, boolean open) throws InterruptedException, ExecutionException, IOException {
    	OFPortMod portMod = new OFPortMod();
    	String action = (open == true) ? "opening" : "closing";

    	for (OFPhysicalPort curPort : floodlightProvider.getSwitches().get(switchId).getFeaturesReplyFromSwitch().get().getPorts()) {
    		if (curPort.getPortNumber() == portNum) portMod.setHardwareAddress(curPort.getHardwareAddress());
    	}

    	portMod.setPortNumber(portNum);
    	portMod.setMask(OFPortConfig.OFPPC_PORT_DOWN.getValue());
    	portMod.setConfig((open == true) ? 0 << 0 : OFPortConfig.OFPPC_PORT_DOWN.getValue());

    	try {
    		logger.debug("Sending ModPort command to switch " + switchId + " - " + action + " port " + portNum);
    		floodlightProvider.getSwitches().get(switchId).write(portMod, null);
    	} catch (Exception e) {
    		logger.error("Error while " + action + " port " + portNum + " on switch " + switchId, e);
    	}
    }
    
	@SuppressWarnings("unused")
	private void printFinalEdges() {
    	String s  = "\n\n";
    	s += "################################################\n" +
             "#####     New MST generated by Kruskal     #####\n" +
             "################################################\n";
    	s += "The minimal spanning tree generated by Kruskal's algorithm is: \n";
    	for (ComparableLink e: topoEdges) {
    		s += "Nodes: (" + e.getDst() + ", " + e.getSrc() + ")";
    	}
    	s += "Following ports will be closed: \n";
    	for (ComparableLink spt : redundantEdges){
    		s += "Port "+ spt + "\n";
    	}
    	s += "##############################################\n";
    	
    	logger.debug(s);
    }
    
	@Override
	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
		Collection<Class<? extends IFloodlightService>> l = new ArrayList<Class<? extends IFloodlightService>>();
	    l.add(IGreenMSTService.class);
	    return l;
	}

	@Override
	public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls() {
		Map<Class<? extends IFloodlightService>, IFloodlightService> m = new HashMap<Class<? extends IFloodlightService>, IFloodlightService>();
	    m.put(IGreenMSTService.class, this);
	    return m;
	}

	@Override
	public Collection<Class<? extends IFloodlightService>> getModuleDependencies() {
		Collection<Class<? extends IFloodlightService>> l = new ArrayList<Class<? extends IFloodlightService>>();
		l.add(IFloodlightProviderService.class);
		l.add(ITopologyService.class);
		l.add(IRestApiService.class);
		return l;
	}

	@Override
	public void init(FloodlightModuleContext context) throws FloodlightModuleException {
		floodlightProvider = context.getServiceImpl(IFloodlightProviderService.class);
		restApi = context.getServiceImpl(IRestApiService.class);
		topology = context.getServiceImpl(ITopologyService.class);
		logger = LoggerFactory.getLogger(GreenMST.class);
	}

	@Override
	public void startUp(FloodlightModuleContext context) {
		if (topology != null) topology.addListener(this);
		restApi.addRestletRoutable(new GreenMSTWebRoutable());
	}
	
	@Override
	public TreeSet<ComparableLink> getTopoEdges() {
		return topoEdges;
	}
	
	@Override
    public HashSet<ComparableLink> getRedundantEdges(){
    	return redundantEdges;
    }
}